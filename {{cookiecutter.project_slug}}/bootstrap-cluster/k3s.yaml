---
version: '3'
env:
  KUBECONFIG: ./{{ '{{.ENV}}' }}/kubeconfig
  SSH_KEY: ~/.ssh/mycnm_default_key
  SANDBOX_INSTANCE_IP: '{{.SANDBOX_INSTANCE_IP}}'
  PROD_INSTANCE_IP: '{{.PROD_INSTANCE_IP}}'
  PROD_PRIVATE_INSTANCE_IP: '{{.PROD_PRIVATE_INSTANCE_IP}}'
tasks:
  bootstrap:
    desc: |
      Run all tasks required to bootstrap k3s and Kubernetes cluster.
    requires:
      vars: [ENV]
    cmds:
      - task: bootstrap_kubernetes
      - sleep 30
      - task: generate_kubeconfig
      - task: store_kubeconfig
      - task: upgrade_talos
      - task: enable_ecr_credential_helper
  bootstrap_kubernetes:
    desc: |
      Bootstrap the Kubernetes cluster on the first control plane node.
    cmds:

  generate_token:
    desc: Generate a random token for k3s cluster
    cmds:
      - tr -dc A-Za-z0-9 </dev/urandom | head -c 13 > prod-token.txt

  install_sandbox:
    desc: Install k3s on sandbox instance
    requires:
      vars: [SANDBOX_INSTANCE_IP]
    cmds:
      - |
        ssh -oStrictHostKeyChecking=no -i ${SSH_KEY} \
          ubuntu@${SANDBOX_INSTANCE_IP} \
          'curl -sfL https://get.k3s.io | \
          INSTALL_K3S_EXEC="--tls-san ${SANDBOX_INSTANCE_IP} --disable=traefik" \
          K3S_KUBECONFIG_MODE="644" sh -s -'

  install_prod:
    desc: Install k3s on main production instance
    requires:
      vars: [PROD_INSTANCE_IP]
    deps: [generate_token]
    cmds:
      - |
        ssh -oStrictHostKeyChecking=no -i ${SSH_KEY} \
          ubuntu@${PROD_INSTANCE_IP} \
          'curl -sfL https://get.k3s.io | K3S_TOKEN=$(cat prod-token.txt) \
          INSTALL_K3S_EXEC="server --cluster-init --tls-san ${PROD_INSTANCE_IP} \
          --disable=traefik" K3S_KUBECONFIG_MODE="644" sh -s -'
      - |
        for ip in $(terraform output -json prod_instance_other_ips | jq -r '.[]'); do
          echo "Installing $ip..."
          ssh -oStrictHostKeyChecking=no -i ${SSH_KEY} ubuntu@$ip \
            'curl -sfL https://get.k3s.io | K3S_TOKEN=$(cat prod-token.txt) \
            INSTALL_K3S_EXEC="server --server https://${PROD_PRIVATE_INSTANCE_IP}:6443 \
            --tls-san ${PROD_INSTANCE_IP} --disable=traefik" \
            K3S_KUBECONFIG_MODE="644" sh -s -'
        done

  enable_ecr_credential_helper:
    desc: |
      Enable the ECR credential helper on all control plane nodes.
    cmds:
      - task: health
      - |
        for node in $(yq -r '.contexts[].endpoints[]' $TALOSCONFIG); do
          talosctl patch mc \
            --nodes $node \
            --patch @patches/patch-ecr-credential-helper.yaml; \
        done
  store_kubeconfig:
    desc: |
      Store the Kubernetes kubeconfig file in AWS Secrets Manager.
    requires:
      vars: [ENV]
    cmds:
      - |
        aws secretsmanager create-secret \
          --name "{{ '{{.ENV}}' }}_kubeconfig" \
          --secret-string "$(base64 -w0 $KUBECONFIG)"
  delete_all_secrets:
    desc: |
      Delete all related secrets from AWS Secrets Manager.
    requires:
      vars: [ENV]
    cmds:
      - |
        aws secretsmanager delete-secret \
          --secret-id "{{ '{{.ENV}}' }}_kubeconfig" \
          --force-delete-without-recovery
  reset_config:
    desc: |
      Remove all config files and delete secrets in AWS Secrets Manager
    requires:
      vars: [ENV]
    cmds:
      - task: delete_all_secrets
      - cd {{ '{{.ENV}}' }} && rm -f kubeconfig

  kubeconfig:
    desc: |
      Retrieve the Kubeconfig for a given cluster

      Since the commands run in sub-shell you can eval the output to export
      KUBECONFIG to your current shell:

        eval $(task talos:kubeconfig)
    silent: true
    cmds:
      - task: generate_kubeconfig
      - echo "export KUBECONFIG=$(pwd)/{{ '{{.ENV}}' }}/kubeconfig"
  fetch_config:
    desc: |
      Fetch kubeconfig from AWS Secrets
      Manager.
    requires:
      vars: [ENV]
    cmds:
      - |
        aws secretsmanager get-secret-value \
          --secret-id "{{ '{{.ENV}}' }}_kubeconfig" | \
          yq ".SecretString" | tr -d '"' | \
          base64 -d > ./{{ '{{.ENV}}' }}/kubeconfig
