#!/usr/bin/env bash

# Scaf challenge script
CHALLENGE_CONFIG_PATH=".scaf-challenge.json"

# Default repository URL if none is provided
DEFAULT_REPO_URL="https://github.com/sixfeetup/scaf/"

# Ensure at least one argument is provided (for project_slug)
if [ $# -lt 1 ]; then
  echo "Usage: $0 project_slug [OPTIONS] [TEMPLATE]"
  exit 1
fi

# The first argument is always the project slug
PROJECT_SLUG="$1"

# Validate the project slug
if ! [[ $PROJECT_SLUG =~ ^[a-zA-Z0-9_-]+$ ]]; then
    echo "Error: PROJECT_SLUG should only contain alphanumeric characters, underscores and hyphens."
    exit 1
fi

# Remove the project_slug from the argument list
shift
CLUSTER_SLUG=${PROJECT_SLUG//_/-}
COOKIECUTTER_SLUG=${PROJECT_SLUG//-/_}

# Assume the last argument is the template URL unless it starts with a dash
if [ $# -gt 0 ]; then
  LAST_ARG="${@: -1}"
  if [[ $LAST_ARG == -* ]]; then
    REPO_URL="$DEFAULT_REPO_URL"
    COOKIECUTTER_OPTIONS="$@"
  else
    REPO_URL="$LAST_ARG"
    # Remove the last argument (the REPO_URL) from the options
    COOKIECUTTER_OPTIONS="${@:1:$(($#-1))}"
  fi
else
  REPO_URL="$DEFAULT_REPO_URL"
  COOKIECUTTER_OPTIONS=""
fi

DOCKER_RUN_OPTIONS=""

# Check if --no-input is in COOKIECUTTER_OPTIONS
if [[ "$COOKIECUTTER_OPTIONS" != *"--no-input"* ]]; then
  DOCKER_RUN_OPTIONS="-it"
fi

# Check if --challenge is in scaf cli arguments
SCAF_CHALLENGE="n"
if [[ $COOKIECUTTER_OPTIONS == *"--challenge"* ]]; then
  SCAF_CHALLENGE="y"
  # Remove `--challenge` from COOKIECUTTER_OPTIONS as these are carried forward and it is not a
  # standard cookiecutter option.
  COOKIECUTTER_OPTIONS=$(echo "${COOKIECUTTER_OPTIONS[@]}" | xargs -n1 | grep -v -- "--challenge" | xargs)
fi

party_popper() {
  for i in {1..4}; do
      echo -ne "\rðŸŽ‰ POP! ðŸ’¥"
      sleep 0.3
      echo -ne "\rðŸ’¥ POP! ðŸŽ‰"
      sleep 0.3
  done
  echo -e "\rðŸŽŠ Congrats! Your $PROJECT_SLUG project is ready! ðŸŽ‰"
  echo
  echo "To get started, run:"
  echo "cd $PROJECT_SLUG"
  echo "tilt up"
  echo
}

start_challenge_oauthflow() {
  # Create a temporary Python server for authorization code flow
  cat << EOF > temp_server.py
from http.server import BaseHTTPRequestHandler, HTTPServer
from urllib.parse import urlparse, parse_qs
import os
import signal

class TokenHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed_path = urlparse(self.path)
        query_params = parse_qs(parsed_path.query)
        if 'code' in query_params:
            code = query_params['code'][0]
            with open('code.txt', 'w') as f:
                f.write(code)
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(b"Authentication was successful. You can close this window now. Thank you!")
            # Signal the parent process
            os.kill(os.getppid(), signal.SIGUSR1)
        else:
            self.send_response(400)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(b"Error: No code provided in the URL.")

def run_server(port=51111):
    server_address = ('', port)
    httpd = HTTPServer(server_address, TokenHandler)
    httpd.serve_forever()

if __name__ == '__main__':
    run_server()
EOF

  # Function to handle the SIGUSR1 signal
  code_received() {
      # Token received. Proceeding to kill HTTP server process.
      kill $server_pid
  }

  # Set up the signal handler
  trap code_received SIGUSR1

  # Start the Python server in the background
  python temp_server.py &
  server_pid=$!

  # Example opening of the browser to auth/reg user
  python -c "import webbrowser; webbrowser.open('https://scaf.withpassage.com/authorize?response_type=code&client_id=961JRDH4c4Sin8LYGGbI0Lb7&redirect_uri=http://localhost:51111&scope=openid%20email')"

  echo "Waiting for authorization..."

  # Wait for the Python script to exit
  wait $server_pid

  # Read the code
  code=$(cat code.txt)

  # Passage OIDC client credentials â€“ move them? (for now, they are hardcoded)
  oidc_client_id="961JRDH4c4Sin8LYGGbI0Lb7"
  oidc_client_secret="gyrskWRKfYccaCffwJGKa0hqekPtbTNJ"

  # Perform the curl request and capture the response
  response=$(curl -s --location --request POST "https://scaf.withpassage.com/token?grant_type=authorization_code&code=$code&redirect_uri=http%3A%2F%2Flocalhost%3A51111&client_id=$oidc_client_id&client_secret=$oidc_client_secret" \
  --header 'Content-Type: application/x-www-form-urlencoded' \
  --data '')

  # Use grep and sed to extract the access_token from the JSON response
  access_token=$(echo $response | grep -o '"access_token":"[^"]*"' | sed -e 's/"access_token":"\([^"]*\)"/\1/')

  # Clean up the Python HTTP server script / code.txt
  rm temp_server.py
  rm code.txt

  # Check if the access_token exists and is not empty
  if [[ -n "$access_token" ]]; then
    echo "Authentication has been completed."
    # write challenge metadata to .scaf-challenge.json
    cat << EOF > .scaf-challenge.json
{
    "access_token": "$access_token",
    "session_id": "$(uuidgen)",
    "base_url": "https://dmxla4ubt9.execute-api.us-east-1.amazonaws.com"
}
EOF
  else
    echo "Error: Access token was not retrieved."
    exit 1
  fi
}

start_challenge_session() {
  # Start a new session and report start timestamp to scaf challenge report API
  echo "Starting challenge session..."

  # Extract token, session_id, and base_url from the challenge config file
  config=$(cat $CHALLENGE_CONFIG_PATH)
  token=$(echo $config | grep -o '"access_token": "[^"]*"' | sed -e 's/"access_token": "\([^"]*\)"/\1/')
  base_url=$(echo $config | grep -o '"base_url": "[^"]*"' | sed -e 's/"base_url": "\([^"]*\)"/\1/')
  session_id=$(echo $config | grep -o '"session_id": "[^"]*"' | sed -e 's/"session_id": "\([^"]*\)"/\1/')
  start=$(python -c "import time; print('{:.6f}'.format(time.time()))")

  # Make report API call to kick off the session
  status_code=$(curl -o /dev/null -s -w "%{http_code}" --location "$base_url/Prod/report" \
    --header "Content-Type: application/json" \
    --header "Authorization: Bearer $token" \
    --data "{ \"sessionid\": \"$session_id\", \"start\": \"$start\" }")

  # Check whether session has been started successfully
  if [[ $status_code -ne 200 ]]; then
      echo "Failed to start the challenge session: $status_code"
      # Force skip challenge if failed to start the session
      SCAF_CHALLENGE="n"
  fi
}

if [[ "$SCAF_CHALLENGE" == "y" ]]; then
  start_challenge_oauthflow
  if [[ -f "$CHALLENGE_CONFIG_PATH" ]]; then
    start_challenge_session
  else
    # Force skip challenge as it cannot be started without config file
    SCAF_CHALLENGE="n"
  fi
else
  echo "Skipping challenge."
fi

echo "DOCKER_RUN_OPTIONS: $DOCKER_RUN_OPTIONS"
echo "COOKIECUTTER_OPTIONS: $COOKIECUTTER_OPTIONS"
echo "REPO_URL: $REPO_URL"

# Challenge config shall exist now if SCAF_CHALLENGE is set to "y" at this point
CHALLENGE_CONFIG=""
if [[ "$SCAF_CHALLENGE" == "y" ]]; then
  CHALLENGE_CONFIG=$(cat $CHALLENGE_CONFIG_PATH)
fi

IMAGE_TAG=${IMAGE_TAG:-latest}
docker run --rm $DOCKER_RUN_OPTIONS -v "$(pwd):/home/scaf/out" \
  -e HOST_UID="$(id -u)" \
  -e HOST_GID="$(id -g)" \
  -e CHALLENGE_CONFIG="$CHALLENGE_CONFIG" \
  docker.io/sixfeetup/scaf:$IMAGE_TAG \
  cookiecutter \
  $COOKIECUTTER_OPTIONS \
  $REPO_URL \
  project_slug="$COOKIECUTTER_SLUG" \
  _challenge="$SCAF_CHALLENGE"


# Check if cookiecutter was successful
if [ $? -eq 0 ]; then
  kind create cluster --name $CLUSTER_SLUG
  cd $COOKIECUTTER_SLUG
  make compile
  echo "Dependencies compiled successfully."
  pwd
  echo "Performing initial commit."
  git add .
  git commit -m "Initial commit"
  party_popper
else
  echo "Failed to create project."
  exit 1
fi
